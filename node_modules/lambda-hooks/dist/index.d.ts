export { handleScheduledEvent, handleUnexpectedError, logEvent, parseEvent } from './hooks';
export interface Hooks {
    before?: Hook[];
    after?: Hook[];
    onError?: Hook[];
}
export declare type Config = {
    [k: string]: any;
};
export declare type Response = any;
export declare type AWSEvent = any;
export declare type AWSContext = any;
export interface State {
    event: AWSEvent;
    context: AWSContext;
    exit: boolean;
    response?: Response;
    error?: any;
    config: any;
}
/**
 * @param state a state object that might be manipulated by this function
 * @param state.event event passed in from AWS
 * @param state.context context passed in from AWS
 * @param state.exit defaults to false, if set to true program will exit early after ivocation of this hook
 * @param state.response returned when state.exit is set to true
 * @param state.error exists only if there's an unhandled exception thrown inside a hook or the lambda handler
 * @returns Promise<state>
 */
export declare type Hook = (state: State) => Promise<State>;
export declare type UseHooks = (hooks: Hooks, config?: Config) => WithHooks;
export declare type WithHooks = (handler: any) => (event: any, context: AWSContext) => Promise<any>;
/**
 * Using the provided hooks create an withHooks higher order function
 * @param hooks a config object of the hooks to apply to your lambda
 * @param hooks.before an array of hooks to run before the provided lambda
 * @param hooks.after an array of hooks to run after the provided lambda
 * @param hooks.onError an array of hooks to run only if there's an error during the execution
 * @returns WithHooks() function that wraps around your lambda
 */
export declare const useHooks: UseHooks;
export default useHooks;
